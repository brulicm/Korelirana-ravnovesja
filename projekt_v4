import numpy as np
import nashpy as nash
from scipy.optimize import linprog

class Igra:
    def __init__(self, koristnosti_igralec1=None, koristnosti_igralec2=None, n=None): # poglej kaj boš z n-jem 
        # če pustimo prazno da naključne vrednosti, če vpišemo določimo - lahko vpišemo koristnosti ali pa n, če oboje preverimo ali ok
        # dodaj pogoj da preverimo če ok
        
        if n is not None:
            self.n = n
        
        else:
            if koristnosti_igralec1 is not None:
                self.n = len(koristnosti_igralec1)
            elif koristnosti_igralec2 is not None:
                self.n = len(koristnosti_igralec2)
            else:
                self.n = np.random.randint(2,6) #če nič potem random število potez med 1 in 10

        if koristnosti_igralec1 is None:
            self.koristnosti_igralec1 = np.random.randint(0, 11, size=(self.n, self.n))
        else:
            self.koristnosti_igralec1 = np.array(koristnosti_igralec1)

        if koristnosti_igralec2 is None:
            self.koristnosti_igralec2 = np.random.randint(0, 11, size=(self.n, self.n))
        else:
            self.koristnosti_igralec2 = np.array(koristnosti_igralec2)

        self.igra = nash.Game(self.koristnosti_igralec1, self.koristnosti_igralec2)

       
    def izračunaj_nashevo_ravnovesje(self):
        eqs = self.igra.vertex_enumeration()
        return list(eqs)
    
    def U(self):
         # konstruiramo matriko U iz definicije koreliranega ravnovesja
         # CE je rešitev LP
         # max x0 + x1 + x2 + x3
         # p. p. Ux >= 0
        a = self.koristnosti_igralec1
        b = self.koristnosti_igralec2
        n = self.n

        U = np.zeros((2*n*(n-1),n*n))
        vrstica = 0

        # za igralca 1
        for i in range(n):
            for j in range(n):
                if i !=j:
                    for s in range(n):
                        U[vrstica, i*n + s] = a[i, s] - a[j, s]
                    vrstica +=1
    
        # za igralca 2
        for i in range(n):
            for j in range(n):
                if i != j:
                    for s in range(n):
                        U[vrstica, s*n + i] = b[s, i] - b[s,j]
                    vrstica += 1
        print(U)
        return U
 
    def reši_lp_max(self):
        # poišče korelirano ravnovesje, ki maximizira dobiček igralca 1
        U = self.U()
        U = -1*U
        A = self.koristnosti_igralec1
        B = self.koristnosti_igralec2

        n = self.n

        # za minimizirat
        cA = -1*A.reshape(-1) # če maks zad 1
        cB = -1*B.reshape(-1) # če maks zad 2
        
        C = A + B
        cC = -1 * C.reshape(-1) # če maks skupno

        # pogoji - desna stran
        b = np.zeros(2*n*(n-1))

        # vsota spremenljivk = 1
        A_eq = np.ones((1, len(cA)))
        b_eq = np.array([1])

        # meje
        x_meje = (0, 1)  # x_i >= 0 for all i, x <=1

        rezultatA = linprog(c = cA, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        rezultatB = linprog(c = cB, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        rezultatC = linprog(c = cC, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        return rezultatA.x, rezultatB.x, rezultatC.x
    

igra2 = Igra([[2,0,3],[0,1, 2], [1,2,3]], [[2,5,7],[0,0, 1], [4,5,6]])

igra = Igra([[2, 0],[0, 1]], [[1,0], [0, 2]])
#print(igra.U())
print(igra.reši_lp_max())
print(igra.izračunaj_nashevo_ravnovesje())

