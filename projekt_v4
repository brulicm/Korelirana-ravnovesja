import numpy as np
import nashpy as nash
from scipy.optimize import linprog

class Igra:
    def __init__(self, koristnosti_igralec1=None, koristnosti_igralec2=None, n=None): # poglej kaj boš z n-jem 
        # če pustimo prazno da naključne vrednosti, če vpišemo določimo - lahko vpišemo koristnosti ali pa n, če oboje preverimo ali ok
        # dodaj pogoj da preverimo če ok
        
        if n is not None:
            self.n = n
        
        else:
            if koristnosti_igralec1 is not None:
                self.n = len(koristnosti_igralec1)
            elif koristnosti_igralec2 is not None:
                self.n = len(koristnosti_igralec2)
            else:
                self.n = np.random.randint(2,6) #če nič potem random število potez med 1 in 10

        if koristnosti_igralec1 is None:
            self.koristnosti_igralec1 = np.random.randint(0, 11, size=(self.n, self.n))
        else:
            self.koristnosti_igralec1 = np.array(koristnosti_igralec1)

        if koristnosti_igralec2 is None:
            self.koristnosti_igralec2 = np.random.randint(0, 11, size=(self.n, self.n))
        else:
            self.koristnosti_igralec2 = np.array(koristnosti_igralec2)

        self.igra = nash.Game(self.koristnosti_igralec1, self.koristnosti_igralec2)

       
    def izračunaj_nashevo_ravnovesje(self):
        eqs = self.igra.vertex_enumeration()
        return list(eqs)
    
    def U(self):
         # konstruiramo matriko U iz definicije koreliranega ravnovesja
         # CE je rešitev LP
         # max x0 + x1 + x2 + x3
         # p. p. Ux >= 0
        a = self.koristnosti_igralec1
        b = self.koristnosti_igralec2
        n = self.n

        U = np.zeros((2*n*(n-1),n*n))
        vrstica = 0

        # za igralca 1
        for i in range(n):
            for j in range(n):
                if i !=j:
                    for s in range(n):
                        U[vrstica, i*n + s] = a[i, s] - a[j, s]
                    vrstica +=1
    
        # za igralca 2
        for i in range(n):
            for j in range(n):
                if i != j:
                    for s in range(n):
                        U[vrstica, s*n + i] = b[s, i] - b[s,j]
                    vrstica += 1
        print(U)
        return U
 
    def reši_lp_max(self):
        # poišče korelirano ravnovesje, ki maximizira dobiček igralca 1
        U = self.U()
        U = -1*U
        A = self.koristnosti_igralec1
        B = self.koristnosti_igralec2

        n = self.n

        # za minimizirat
        cA = -1*A.reshape(-1) # če maks zad 1
        cB = -1*B.reshape(-1) # če maks zad 2
        
        C = A + B
        cC = -1 * C.reshape(-1) # če maks skupno

        # pogoji - desna stran
        b = np.zeros(2*n*(n-1))

        # vsota spremenljivk = 1
        A_eq = np.ones((1, len(cA)))
        b_eq = np.array([1])

        # meje
        x_meje = (0, 1)  # x_i >= 0 for all i, x <=1

        rezultatA = linprog(c = cA, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        rezultatB = linprog(c = cB, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        rezultatC = linprog(c = cC, A_ub = U, b_ub = b, A_eq = A_eq, b_eq = b_eq)
        print("_____________________")
        print("Korelirano ravnovesje pri katerem je maksimizirano zadovoljstvo igralca 1:")
        print(rezultatA.x)
        print("Koristnost igralca 1:")
        print(-rezultatA.fun)
        print("Koristnost igralca 2:")
        print(np.matmul(B.reshape(-1), rezultatA.x))
        print("Skupno zadovoljstvo:")
        print(np.matmul(C.reshape(-1), rezultatA.x))
        print("_____________________")

        print("Korelirano ravnovesje pri katerem je maksimizirano zadovoljstvo igralca 2:")
        print(rezultatB.x)
        print("Koristnost igralca 1:")
        print(np.matmul(A.reshape(-1), rezultatB.x))
        print("Koristnost igralca 2:")
        print(-rezultatB.fun)
        print("Skupno zadovoljstvo:")
        print(np.matmul(C.reshape(-1), rezultatB.x))

        print("_____________________")
        print("Korelirano ravnovesje pri katerem je maksimizirano skupno zadovoljstvo:")
        print(rezultatC.x)
        print("Koristnost igralca 1:")
        print(np.matmul(A.reshape(-1), rezultatC.x))
        print("Koristnost igralca 2:")
        print(np.matmul(B.reshape(-1), rezultatC.x))

        print("Skupno zadovoljstvo")
        print(-rezultatC.fun)
        return rezultatA.x, rezultatB.x, rezultatC.x
    

# stragopetec
igra = Igra([[2, 0],[0, 1]], [[1,0], [0, 2]])
nashevo_ravnovesje = igra.izračunaj_nashevo_ravnovesje()

print("Nashevo ravnovesje:")
print(nashevo_ravnovesje)

korelirano1 = igra.reši_lp_max()

# naključna 2x2 
igra2 = Igra(n=2)
print(igra2.igra)
nashevo_ravnovesje2 = igra2.izračunaj_nashevo_ravnovesje()

print("Nashevo ravnovesje:")
print(nashevo_ravnovesje2)

korelirano3 = igra2.reši_lp_max()

# naključna 3x3
#igra3 = Igra(n = 3)
#print(igra3.igra)
#nashevo_ravnovesje3 = igra3.izračunaj_nashevo_ravnovesje()

#print("Nashevo ravnovesje:")
#print(nashevo_ravnovesje3)

#korelirano3 = igra3.reši_lp_max()